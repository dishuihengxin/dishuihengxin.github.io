<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据库架构 on 滴水恒心</title><link>https://www.dishuihengxin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/</link><description>Recent content in 数据库架构 on 滴水恒心</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Wed, 31 Dec 2025 22:00:00 +0800</lastBuildDate><atom:link href="https://www.dishuihengxin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL分库分表实践：从理论到落地的全面指南</title><link>https://www.dishuihengxin.com/posts/database-mysql-sharding/</link><pubDate>Wed, 31 Dec 2025 22:00:00 +0800</pubDate><guid>https://www.dishuihengxin.com/posts/database-mysql-sharding/</guid><description>&lt;h1 id="mysql分库分表实践从理论到落地的全面指南"&gt;MySQL分库分表实践：从理论到落地的全面指南&lt;/h1&gt;
&lt;p&gt;随着业务数据量的爆发式增长，单库单表的MySQL架构往往无法满足高并发、大数据量的业务需求。分库分表作为解决数据库容量和性能瓶颈的关键技术，已成为大型互联网应用的标配。本文将从理论到实践，全面介绍MySQL分库分表的实施方案和最佳实践。&lt;/p&gt;
&lt;h2 id="分库分表基础理论"&gt;分库分表基础理论&lt;/h2&gt;
&lt;h3 id="为什么需要分库分表"&gt;为什么需要分库分表&lt;/h3&gt;
&lt;p&gt;在讨论具体实现方案前，我们需要明确分库分表的驱动因素：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;驱动因素&lt;/th&gt;
 &lt;th&gt;表现&lt;/th&gt;
 &lt;th&gt;影响&lt;/th&gt;
 &lt;th&gt;解决方案&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;数据量过大&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;单表数据超过千万级&lt;/td&gt;
 &lt;td&gt;查询性能下降，索引效率降低&lt;/td&gt;
 &lt;td&gt;水平分表&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;写入压力大&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;高并发写入导致锁竞争&lt;/td&gt;
 &lt;td&gt;写入延迟增加，影响用户体验&lt;/td&gt;
 &lt;td&gt;水平分库&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;读取压力大&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;查询响应时间增加&lt;/td&gt;
 &lt;td&gt;系统整体性能下降&lt;/td&gt;
 &lt;td&gt;读写分离+分库&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;单机资源瓶颈&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;CPU/内存/IO资源不足&lt;/td&gt;
 &lt;td&gt;数据库服务不稳定&lt;/td&gt;
 &lt;td&gt;分库+硬件扩容&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="分库分表的基本概念"&gt;分库分表的基本概念&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-mermaid" data-lang="mermaid"&gt;graph TB
 subgraph &amp;#34;分库分表模式&amp;#34;
 A[原始数据库]
 
 subgraph &amp;#34;垂直分库&amp;#34;
 B1[用户库]
 B2[订单库]
 B3[商品库]
 end
 
 subgraph &amp;#34;垂直分表&amp;#34;
 C1[用户基本信息表]
 C2[用户详细信息表]
 C3[用户行为表]
 end
 
 subgraph &amp;#34;水平分库&amp;#34;
 D1[库0]
 D2[库1]
 D3[库n]
 end
 
 subgraph &amp;#34;水平分表&amp;#34;
 E1[表0]
 E2[表1]
 E3[表n]
 end
 
 A --&amp;gt; B1
 A --&amp;gt; B2
 A --&amp;gt; B3
 
 A --&amp;gt; C1
 A --&amp;gt; C2
 A --&amp;gt; C3
 
 A --&amp;gt; D1
 A --&amp;gt; D2
 A --&amp;gt; D3
 
 A --&amp;gt; E1
 A --&amp;gt; E2
 A --&amp;gt; E3
 end
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="垂直拆分"&gt;垂直拆分&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;垂直分库&lt;/strong&gt;：按业务领域将不同表拆分到不同的数据库中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;垂直分表&lt;/strong&gt;：将一个表按字段拆分成多个表，每个表存储部分字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="水平拆分"&gt;水平拆分&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;水平分库&lt;/strong&gt;：将同一个表的数据按照某个维度分散到不同的数据库中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;水平分表&lt;/strong&gt;：将同一个表的数据按照某个维度分散到同一个数据库的多个表中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="分片策略设计"&gt;分片策略设计&lt;/h2&gt;
&lt;h3 id="分片键选择"&gt;分片键选择&lt;/h3&gt;
&lt;p&gt;分片键的选择直接影响分库分表的效率和均衡性，常见的分片键选择策略：&lt;/p&gt;</description></item><item><title>PostgreSQL高可用架构设计与实践：从主从复制到分布式集群</title><link>https://www.dishuihengxin.com/posts/database-postgresql-ha/</link><pubDate>Wed, 31 Dec 2025 22:00:00 +0800</pubDate><guid>https://www.dishuihengxin.com/posts/database-postgresql-ha/</guid><description>&lt;h1 id="postgresql高可用架构设计与实践从主从复制到分布式集群"&gt;PostgreSQL高可用架构设计与实践：从主从复制到分布式集群&lt;/h1&gt;
&lt;p&gt;在现代企业级应用中，数据库的高可用性是系统稳定运行的基石。PostgreSQL作为功能强大的开源关系型数据库，提供了多种高可用解决方案。本文将深入探讨PostgreSQL高可用架构的设计原理和实践方案，从基础的主从复制到复杂的分布式集群部署。&lt;/p&gt;
&lt;h2 id="postgresql高可用架构概述"&gt;PostgreSQL高可用架构概述&lt;/h2&gt;
&lt;h3 id="高可用性指标定义"&gt;高可用性指标定义&lt;/h3&gt;
&lt;p&gt;在设计PostgreSQL高可用架构时，我们需要明确以下关键指标：&lt;/p&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;指标&lt;/th&gt;
 &lt;th&gt;定义&lt;/th&gt;
 &lt;th&gt;目标值&lt;/th&gt;
 &lt;th&gt;影响因素&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;可用性(Availability)&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;系统正常运行时间比例&lt;/td&gt;
 &lt;td&gt;99.9% - 99.99%&lt;/td&gt;
 &lt;td&gt;故障检测、切换时间&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;恢复时间目标(RTO)&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;系统故障后恢复服务的最大时间&lt;/td&gt;
 &lt;td&gt;&amp;lt; 5分钟&lt;/td&gt;
 &lt;td&gt;自动化程度、网络延迟&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;恢复点目标(RPO)&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;可接受的最大数据丢失量&lt;/td&gt;
 &lt;td&gt;&amp;lt; 1分钟&lt;/td&gt;
 &lt;td&gt;复制延迟、同步策略&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;strong&gt;故障检测时间(MTTR)&lt;/strong&gt;&lt;/td&gt;
 &lt;td&gt;从故障发生到检测到的时间&lt;/td&gt;
 &lt;td&gt;&amp;lt; 30秒&lt;/td&gt;
 &lt;td&gt;监控频率、健康检查&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="高可用架构模式"&gt;高可用架构模式&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-mermaid" data-lang="mermaid"&gt;graph TB
 subgraph &amp;#34;单机模式&amp;#34;
 A[Primary Server]
 A1[定期备份]
 A --&amp;gt; A1
 end
 
 subgraph &amp;#34;主从复制模式&amp;#34;
 B[Primary Server]
 B1[Standby Server 1]
 B2[Standby Server 2]
 B --&amp;gt; B1
 B --&amp;gt; B2
 end
 
 subgraph &amp;#34;主从+负载均衡模式&amp;#34;
 C[Primary Server]
 C1[Standby Server 1]
 C2[Standby Server 2]
 C3[Load Balancer]
 C3 --&amp;gt; C
 C3 --&amp;gt; C1
 C3 --&amp;gt; C2
 C --&amp;gt; C1
 C --&amp;gt; C2
 end
 
 subgraph &amp;#34;分布式集群模式&amp;#34;
 D[Node 1]
 D1[Node 2]
 D2[Node 3]
 D3[Coordinator]
 D3 --&amp;gt; D
 D3 --&amp;gt; D1
 D3 --&amp;gt; D2
 D &amp;lt;--&amp;gt; D1
 D1 &amp;lt;--&amp;gt; D2
 D2 &amp;lt;--&amp;gt; D
 end
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="流复制streaming-replication配置"&gt;流复制(Streaming Replication)配置&lt;/h2&gt;
&lt;h3 id="主服务器配置"&gt;主服务器配置&lt;/h3&gt;
&lt;p&gt;首先配置主服务器的PostgreSQL参数：&lt;/p&gt;</description></item></channel></rss>